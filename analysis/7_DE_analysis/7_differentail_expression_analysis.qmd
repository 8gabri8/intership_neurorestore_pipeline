---
title: "differentail_expression_analisys"
format: html
editor: visual
---

Run DE analisys for a specific Injection Region.
Deafault test: edgeR with LRT, Benjamini-Hochber FDR control (p-valu adjustmet), no normalization prior to glm fitting

**ATTENTION**:
- It analyses "Synapses" counts
- To know if a region is significant it uses the p-value-adj
- analysis only leaves
- using the functuion differential_activity you can perform other tests

# Libraries

```{r}
library(magrittr)
library(tidyr)
library(dplyr)
library(tibble)
library(forcats)
```

# Differential_activity.R Function
```{r}
#' Run differential activation (based on bulk RNA-seq analysis)
#' 
#' Run differential activation (based on bulk RNA-seq analysis)
#' 
#' @param input a count matrix to be analyzed, with features (regions) in rows
#'   and brains in columns. 
#' @param meta the accompanying meta data whereby the rownames match the column
#'   names of \code{input}.
#' @param replicate_col the vector in \code{meta} containing the replicate 
#'   information. Defaults to \code{replicate}.
#' @param label_col the vector in \code{meta} containing the experimental
#'   label. Defaults to \code{label}. 
#' @param min_features the minimum number of expressing brains
#'   for a region to retain it. Defaults to \code{0}.
#' @param de_method the specific differential expression testing method to use.
#'   Defaults to edgeR.
#' @param de_type the specific parameter of the differential expression testing
#'   method. Defaults to LRT for edgeR, LRT for DESeq2, and trend for limma.
#' @return a data frame containing differential expression results.
#'  
#' @importFrom magrittr %<>%
#' @importFrom tibble rownames_to_column
#' @importFrom dplyr %>% mutate n_distinct
#' @importFrom edgeR DGEList calcNormFactors estimateDisp glmQLFit glmQLFTest
#'   glmFit glmLRT topTags cpm
#' @importFrom DESeq2 DESeqDataSetFromMatrix DESeq results
#' @importFrom limma voom lmFit eBayes topTable
#' @importFrom purrr map 
#' @importFrom stats model.matrix
#' @importFrom methods new
#' 
#' @export
differential_activity = function(input, 
                         meta = NULL, 
                         replicate_col = 'replicate',
                         label_col = 'label',
                         min_features = 0,
                         de_family = 'pseudobulk',
                         de_method = 'edgeR',
                         de_type = 'LRT',
                         normalise = TRUE) {
  # check args
  if (de_method == 'limma') {
    if (de_type != 'voom') {
      # change default type to use
      de_type = 'trend'  
    }
  }
  
  # define a targets df
  targets = meta

  ## optionally, carry over factor levels from entire dataset
  if (is.factor(meta$label)) {
    targets$label %<>% factor(levels = levels(meta$label))
  }
  if (n_distinct(targets$label) > 2)
    return(NULL)
  # create design
  #design = model.matrix(~ label_col, data = targets)
  design = model.matrix(~ label, data = targets)
  
  DA = switch(de_method,
              edgeR = {
                tryCatch({
                  if(normalise == TRUE){
                    y = DGEList(counts = input, group = targets$label) %>%
                      calcNormFactors(method = 'TMM') %>%
                      estimateDisp(design)
                  } else{
                    y = DGEList(counts = input, group = targets$label) %>%
                      estimateDisp(design)
                  }
                  test = switch(de_type,
                                QLF = {
                                  fit = glmQLFit(y, design)
                                  test = glmQLFTest(fit, coef = -1)
                                },
                                LRT = {
                                  fit = glmFit(y, design = design)
                                  test = glmLRT(fit)
                                })
                  res = topTags(test, n = Inf, adjust.method = "BH") %>%
                    as.data.frame() %>%
                    rownames_to_column('region') %>%
                    # flag metrics in results
                    mutate(de_family = 'pseudobulk',
                           de_method = de_method,
                           de_type = de_type)
                }, error = function(e) {
                  message(e)
                  data.frame()
                })
              },
              DESeq2 = {
                tryCatch({
                  dds = DESeqDataSetFromMatrix(countData = input,
                                               colData = targets,
                                               design = ~ label)
                  dds = switch(de_type,
                               Wald = {
                                 dds = try(DESeq(dds,
                                                 test = 'Wald',
                                                 fitType = 'parametric',
                                                 sfType = 'poscounts',
                                                 betaPrior = F))
                               },
                               LRT = {
                                 dds = try(DESeq(dds,
                                                 test = 'LRT',
                                                 reduced = ~ 1,
                                                 fitType = 'parametric',
                                                 sfType = 'poscounts',
                                                 betaPrior = F))
                               }
                  )
                  res = results(dds)
                  # write
                  res = as.data.frame(res) %>%
                    mutate(region = rownames(input)) %>%
                    # flag metrics in results
                    mutate(de_family = 'pseudobulk',
                           de_method = de_method,
                           de_type = de_type)
                }, error = function(e) {
                  message(e)
                  data.frame()
                })
              },
              limma = {
                tryCatch({
                  x = switch(de_type,
                             trend = {
                               trend_bool = T
                               dge = DGEList(as.matrix(input), group = targets$label)
                               dge = calcNormFactors(dge)
                               x = new("EList")
                               x$E = cpm(dge, log = TRUE, prior.count = 3)
                               x
                             },
                             voom = {
                               counts = all(as.matrix(input) %% 1 == 0)
                               if (counts) {
                                 trend_bool = F
                                 x = voom(as.matrix(input), design)
                                 x
                               }
                             })
                  # get fit
                  fit = lmFit(x, design) %>%
                    eBayes(trend = trend_bool, robust = trend_bool)
                  # format the results
                  res = fit %>%
                    # extract all coefs except intercept
                    topTable(number = Inf, coef = -1) %>%
                    rownames_to_column('region') %>%
                    # flag metrics in results
                    mutate(
                      de_family = 'pseudobulk',
                      de_method = de_method,
                      de_type = de_type)
                }, error = function(e) {
                  message(e)
                  data.frame()
                })
              }
  )
  
  # clean up the output
  suppressWarnings(
    colnames(DA) %<>%
      fct_recode('p_val' = 'p.value',  ## DESeq2
                 'p_val' = 'pvalue',  ## DESeq2
                 'p_val' = 'p.value',  ## t/wilcox
                 'p_val' = 'P.Value',  ## limma
                 'p_val' = 'PValue'  , ## edgeR
                 'p_val_adj' = 'padj', ## DESeq2/t/wilcox
                 'p_val_adj' = 'adj.P.Val',      ## limma
                 'p_val_adj' = 'FDR',            ## edgeER
                 'avg_logFC' = 'log2FoldChange', ## DESEeq2
                 'avg_logFC' = 'logFC' ## limma/edgeR
      )
  ) %>%
    as.character()
  
  DA %<>%
    # calculate adjusted p values
    mutate(p_val_adj = p.adjust(p_val, method = 'BH')) %>%
    # make sure region is a character not a factor
    mutate(region = as.character(region)) %>%
    dplyr::select(region,
                  avg_logFC,
                  p_val,
                  p_val_adj,
                  de_family,
                  de_method,
                  de_type
    ) %>%
    ungroup() %>%
    arrange(p_val_adj)
  
}
```

# Mandatory Inputs
```{r}
# Select one region of Injection
region_injection = "DR"
# Contrast to compare
contrasts = list(c("1 weeks", "8 weeks"), c("Uninjured", "1 weeks"), c("Uninjured", "8 weeks"))
# max p-avleu over with a region is no more signification (referred to adjusted p-value)
p_value = 0.05
# How many most differt ROI display
n_roi_diplayed = 20
# Save folder
save_path = "/run/user/1000/gvfs/smb-share:server=upcourtinenas,share=cervical/CERVICAL_ID/Connectome_analysis/Final_dataset/Results"

# Load data
df_all = read.csv("/run/user/1000/gvfs/smb-share:server=upcourtinenas,share=cervical/CERVICAL_ID/Connectome_analysis/Final_dataset/Results/all_brains.csv")
df_meta_all = read.csv("/run/user/1000/gvfs/smb-share:server=upcourtinenas,share=cervical/CERVICAL_ID/Connectome_analysis/Final_dataset/Results/all_brains_meta.csv")

```

# Run DE analysis

```{r}

# big df with all contratss
df_da_all_contrasts = data.frame()

for (contrast in contrasts){
  
  baseline = contrast[1]
  treated = contrast[2]
  
  # Select only relative data
  df = df_all[(df_all$TimePoint %in% contrast) & 
              (df_all$`Region.Injection` == region_injection),]
  
  # Select only leaves ROI
  df = df[df$IsLeaf == "True",]
  
  # Create meta df
  df_meta = df_meta_all[(df_meta_all$TimePoint %in% contrast) & 
                        (df_meta_all$`Region.Injection` == region_injection),]
  df_meta$TimePoint = as.factor(df_meta$TimePoint)
  df_meta = df_meta %>% rename(label = TimePoint) # ATTENTION: MUST BE CALLED "LABEL" FOR NEXTY FUNCTION
  df_meta$label <- relevel(df_meta$label, ref = baseline) # ATTENTION: SET THE BALINE CONDTION THAT YOU WANT

  
  # Pivot data (to create a count matrix)
  df <- pivot_wider(df, 
                    id_cols = ROI, 
                    names_from = c(`Brain.ID`, `Region.Injection`, TimePoint), 
                    values_from = `Synapses`)
  
  # create counts
  counts <- as.matrix(df[,-1])  # Assuming the first column is ROI and should be excluded
  rownames(counts) <- df$ROI   # Set gene names as rownames
  colnames(counts) <- df_meta$Brain.ID # Check column names to ensure they match metadata
    
  # Perform the test
  da_df = differential_activity(input = counts, 
                           meta = df_meta, 
                           replicate_col = 'replicate',
                           label_col = 'label',
                           min_features = 0,
                           de_family = 'pseudobulk',
                           de_method = 'edgeR',
                           de_type = 'LRT',
                           normalise = FALSE) # I do not normalize
  
  # Add columns to df
  da_df = da_df %>%
          mutate(baseline = baseline,
                 treated= treated) %>%
          # add the direction!!
          mutate(direction = ifelse(avg_logFC < 0, 
                                    paste0(treated, ' < ', baseline), # ATTENTION: use only "<", to have continutity with future code
                                    paste0(baseline, ' < ', treated)),
                 significant = ifelse(p_val_adj < p_value, "*", "n.s."))
  
    
    print(da_df)
    
    # Add ot the df contrast list
    df_da_all_contrasts = rbind(df_da_all_contrasts, da_df)
    
    
}


# Display the merged data frame
print(df_da_all_contrasts) #1680 ROIs x 2contarts = 5040
```



# Asses Archetypes
```{r}
# Just change name
da = df_da_all_contrasts



## Archetype 1: 1w < UN and 1w < 8w --> "RECOVERY"
## (gradually improving and reaching baseline levels by increasing)
arch_a1 = "Recovery"
a1 = da %>%
  filter(p_val_adj < 0.05) %>%
  filter(direction %in% c("1 weeks < Uninjured", "1 weeks < 8 weeks")) %>% # Take only the rows of these 2 conditions
  # ask which ones have both criteria
  group_by(region) %>% #Create groups based on the ROI
  mutate(count = n()) %>%
  filter(count == 2) %>% #Take only the gouprs(ROI) that have 2 rows --> i.e  regions that meet both criteria
  ungroup() %>%
  mutate(archetype = arch_a1, region_injection = region_injection)

# try looking by rank even if they are not significant
  # do not take into accou tp-value
  #calculates a cumulative rank: regions sorted by their cumulative rank, indicating how well the regions rank overall in terms of their p-values across the specified conditions.
a1_rank = da %>%
  filter(direction %in% c("1 weeks < Uninjured", "1 weeks < 8 weeks")) %>%
  # ask which ones have both criteria
  group_by(region) %>%
  mutate(count = n()) %>%
  filter(count == 2) %>%
  group_by(direction) %>% # creates 2 grousp (one for each direction, i.e. pair of condtions)
  arrange(p_val_adj) %>%
  mutate(rank = rank(p_val_adj)) %>% # in each group(direction of before), give a point based on rank
  group_by(region) %>%
  mutate(sum_rank = sum(rank)) %>% #sum the 2 rnaks of the 2 directiosn in acumulative rank
  ungroup() %>%
  arrange(sum_rank) %>%
  dplyr::select(region, sum_rank) %>%
  distinct() %>%
  tail(n_roi_diplayed) %>%# Takr the one with biggest ranks
  mutate(archetype = arch_a1, region_injection = region_injection)



## Archetype 2: UN < 1wk and 8w < 1w 
## (gradually improving and reaching baseline levels by decreasing)
arch_a2 = "Recovery Down"
a2 = da %>%
  filter(p_val_adj < 0.05) %>%
  filter(direction %in% c("Uninjured < 1 weeks", "8 weeks < 1 weeks")) %>%
  # ask which ones have both criteria
  group_by(region) %>%
  mutate(count = n()) %>%
  filter(count == 2) %>%
  ungroup() %>%
  mutate(archetype = arch_a2, region_injection = region_injection)

# try looking by rank even if they are not significant
a2_rank = da %>%
  filter(direction %in% c("Uninjured < 1 weeks", "8 weeks < 1 weeks")) %>%
  # ask which ones have both criteria
  group_by(region) %>%
  mutate(count = n()) %>%
  filter(count == 2) %>%
  group_by(direction) %>%
  arrange(p_val_adj) %>%
  mutate(rank = rank(p_val_adj)) %>%
  group_by(region) %>%
  mutate(sum_rank = sum(rank)) %>%
  ungroup() %>%
  arrange(sum_rank) %>%
  dplyr::select(region, sum_rank) %>%
  distinct() %>%
  tail(n_roi_diplayed) %>%
  mutate(archetype = arch_a2, region_injection = region_injection)



# ## Archetype 3: (1w, 3w, 8w) < UN 
# ## (region getting fucked by the injury that could be interesting 
# ## to look into and target)
# a3 = da %>%
#   filter(p_val < 0.05) %>%
#   filter(direction %in% c("1 weeks < Uninjured", "3 weeks < Uninjured", # ???? 3 weeks ????
#                           "8 weeks < Uninjured")) %>%
#   # ask which ones have both criteria
#   group_by(region) %>%
#   mutate(count = n()) %>%
#   filter(count == 3) %>%
#   ungroup() %>%
#   mutate(archetype = arch_a3, region_injection = region_injection)
# 
# # try looking by rank even if they are not significant
# a3_rank = da %>%
#   filter(direction %in% c("1w < Uninjured", "3w < Uninjured",
#                           "8w < Uninjured")) %>%
#   # ask which ones have both criteria
#   group_by(region) %>%
#   mutate(count = n()) %>%
#   filter(count == 3) %>%
#   group_by(direction) %>%
#   arrange(p_val) %>%
#   mutate(rank = rank(p_val)) %>%
#   group_by(region) %>%
#   mutate(sum_rank = sum(rank)) %>%
#   ungroup() %>%
#   arrange(sum_rank) %>%
#   dplyr::select(region, sum_rank) %>%
#   distinct()
# head(a3_rank, 20)



## Archetype 4: UN < 1w and 1w < 8w --> New Connections
## (region gradually becoming more and more active to compensate 
## for the loss of function)
arch_a4 = "New Connections"
a4 = da %>%
  filter(p_val_adj < 0.05) %>%
  filter(direction %in% c("Uninjured < 1 weeks", "1 weeks < 8 weeks")) %>%
  # ask which ones have both criteria
  group_by(region) %>%
  mutate(count = n()) %>%
  filter(count == 2) %>%
  ungroup() %>%
  mutate(archetype = arch_a4, region_injection = region_injection)

# try looking by rank even if they are not significant
a4_rank = da %>%
  filter(direction %in% c("Uninjured < 1 weeks", "1 weeks < 8 weeks")) %>%
  # ask which ones have both criteria
  group_by(region) %>%
  mutate(count = n()) %>%
  filter(count == 2) %>%
  group_by(direction) %>%
  arrange(p_val_adj) %>%
  mutate(rank = rank(p_val_adj)) %>%
  group_by(region) %>%
  mutate(sum_rank = sum(rank)) %>%
  ungroup() %>%
  arrange(sum_rank) %>%
  dplyr::select(region, sum_rank) %>%
  distinct() %>%
  tail(n_roi_diplayed) %>%
  mutate(archetype = arch_a4, region_injection = region_injection)


```


```{r}
# Merge all of them together
df_significant = rbind(a1, a2, a4)
df_rank = rbind(a1_rank, a2_rank, a4_rank)

# Save
save_folder = paste0(save_path, "/DE_analysis_", region_injection)
if (!file.exists(save_folder)) {
  dir.create(save_folder)
}
write.csv(df_significant, paste0(save_folder, "/significant_roi_archetypes_", region_injection, ".csv"))
write.csv(df_rank, paste0(save_folder, "/rank_roi_archetypes_", region_injection, ".csv"))

```





















